# Single Cell Analysis

<!---
Please be patient, it can take 5 to 10 minutes to prepare Rmarkdown!!
-->

```{r, echo=FALSE, message=FALSE}
library("SignallingSingleCell")
library("SingleCellExperiment")
library(RCurl)
load(url("https://dolphinnext.umassmed.edu/tmp/pub/1LAHzyVubEvUFbnpp0tPfSKg5a14k8/pubweb/rdata/masterdata.Rdata"))
ex_sc <- construct_ex_sc(master_data) # sc_dat == Input expression matrix
rm(master_data)
``` 

## Filtering
Note how many low UMI count cells are in the data!

```{r, echo=FALSE, message=FALSE}
ex_sc <- calc_libsize(ex_sc) # sums counts for each cell
plot_density(ex_sc, title = "UMI Density (Before Filtration)", val = "UMI_sum", statistic = "mean") 
``` 

Average UMI_sum/cell before filtration:

```{r, echo=FALSE, message=FALSE}
mean(pData(ex_sc)$UMI_sum)
```

```{r, echo=FALSE, message=FALSE}
ex_sc <- pre_filter(ex_sc, threshold = 1, minCells = 10, minUMI = 500, maxUMI = 10000, print_progress = TRUE) # filters cells and genes
ex_sc <- calc_libsize(ex_sc)
plot_density(ex_sc, title = "UMI Density (After Filtration)",  val = "UMI_sum", statistic = "mean")  
``` 

Average UMI_sum/cell after filtration:

```{r, echo=FALSE, message=FALSE}
mean(pData(ex_sc)$UMI_sum)
``` 

## Dimension reduction
Before normalization dimensionality reduction is necessary to form preliminary clusters. These clusters are used to normalize internal to a cluster before normalizing across clusters. First we can subset the genes, and then use these feature selected genes for dimension reduction.

```{r, echo=FALSE, message=FALSE}
dim_reduce <- function (input, genelist = gene_subset, pre_reduce = "iPCA", 
    nComp = 15, tSNE_perp = 30, iterations = 1000, print_progress = TRUE, 
    nVar = NA) 
{
    input_exp <- exprs(input)[genelist, ]
    input_scale <- scale(log2(input_exp[, ] + 2) - 1)
    check <- grep("Comp", colnames(pData(input)))
    if (length(check) > 0) {
        pData(input) <- pData(input)[, -check]
    }
    if (pre_reduce == "ICA") {
        if (print_progress == TRUE) {
            print("Starting ICA")
        }
        ica <- fastICA::fastICA(t(input_scale), n.comp = (nComp), 
            alg.typ = "parallel", fun = "logcosh", alpha = 1, 
            method = "C", verbose = print_progress)
        colnames(ica$A) <- gene_subset
        rownames(ica$S) <- colnames(input)
        set.seed(100)
        if (print_progress == TRUE) {
            print("Starting tSNE")
        }
        tsne_input = ica$S
        colnames(ica$S) <- paste0("IC_Comp", seq(1:ncol(ica$S)))
    }
    if (pre_reduce == "PCA") {
        if (print_progress == TRUE) {
            print("Starting PCA")
        }
        PCA <- irlba::prcomp_irlba(t(input_scale), nComp, center = F)
        rownames(PCA$x) <- colnames(input)
        colnames(PCA$x) <- paste0("PC_Comp", seq(1:ncol(PCA$x)))
        set.seed(100)
        if (print_progress == TRUE) {
            print("Starting tSNE")
        }
        tsne_input = PCA$x
    }
    if (pre_reduce == "iPCA") {
        if (print_progress == TRUE) {
            print("Starting iPCA")
        }
        iPCA <- irlba::prcomp_irlba(input_scale, nComp, center = F)
        rownames(iPCA$rotation) <- colnames(input)
        colnames(iPCA$rotation) <- paste0("iPC_Comp", seq(1:ncol(iPCA$rotation)))
        set.seed(100)
        if (print_progress == TRUE) {
            print("Starting tSNE")
        }
        tsne_input = iPCA$rotation
    }
    if (pre_reduce == "vPCA") {
        if (print_progress == TRUE) {
            print("Starting vPCA")
        }
        vPCA <- irlba::prcomp_irlba(log10(input_exp + 1), n = nComp, 
            scale. = T)
        var = vPCA$sdev^2/sum(vPCA$sdev^2)
        totalvar = var[1]
        maxPC = 1
        while (totalvar < nVar) {
            maxPC = maxPC + 1
            totalvar = sum(var[1:maxPC])
        }
        vPCA$rotation = vPCA$rotation[, 1:maxPC]
        rownames(vPCA$rotation) <- colnames(input)
        colnames(vPCA$rotation) <- paste0("iPC_Comp", seq(1:ncol(vPCA$rotation)))
        set.seed(100)
        if (print_progress == TRUE) {
            print("Starting tSNE")
        }
        tsne_input = vPCA$rotation
    }
    tSNE_result <- Rtsne::Rtsne(tsne_input, dims = 2, perplexity = tSNE_perp, 
        theta = 0.5, check_duplicates = F, pca = F, max_iter = iterations, 
        verbose = print_progress)
    tSNE_result <- tSNE_result$Y
    row.names(tSNE_result) <- rownames(tsne_input)
    colnames(tSNE_result) <- c("x", "y")
    tSNE_result[, "x"] <- abs(min(tSNE_result[, "x"])) + tSNE_result[, 
        "x"]
    tSNE_result[, "x"] <- tSNE_result[, "x"]/max(tSNE_result[, 
        "x"])
    tSNE_result[, "y"] <- abs(min(tSNE_result[, "y"])) + tSNE_result[, 
        "y"]
    tSNE_result[, "y"] <- tSNE_result[, "y"]/max(tSNE_result[, 
        "y"])
    prelim_dims <- cbind(tSNE_result, tsne_input)
    pData(input)$x <- prelim_dims[, "x"]
    pData(input)$y <- prelim_dims[, "y"]
    index <- grep("Comp", colnames(prelim_dims))
    pData(input) <- cbind(pData(input), prelim_dims[, index])
    return(input)
}

gene_subset <- subset_genes(ex_sc, method = "PCA", threshold = 1, minCells = 30, nComp = 10, cutoff = 0.85) # 3 available methods for selecting genes
ex_sc <- dim_reduce(ex_sc, genelist = gene_subset, pre_reduce = "iPCA", nComp = 15, tSNE_perp = 50, iterations = 500, print_progress=TRUE)  # 3 available methods for dimensionality reduction
plot_tsne_metadata(ex_sc, color_by = "UMI_sum", title = "Total UMIs per cell") 
```

# Initial Clustering

```{r, echo=FALSE, message=FALSE}
ex_sc <- cluster_sc(ex_sc, dimension = "2d", method = "density", s = 2) # 2 clustering algorithms can be performed on 2d plots or PCA / ICA components
plot_tsne_metadata(ex_sc, color_by = "Cluster", title = "Spectral Cluster on iPCA components") # this function is flexible for plotting any data onto a 2d tsne mapping
plot_density(ex_sc, title = "UMIs per cluster", val = "UMI_sum", color_by = "Cluster", statistic = "mean")
plot_density_ridge(ex_sc, title = "UMIs per cluster", val = "UMI_sum", color_by = "Cluster")
```

# Normalization
Now that the data has preliminary clusters, we can normalize. SCRAN normalization will first normalize internally in clusters, before normalizing across clusters. Once the data is normalized we can run the same steps as above before visualization. The first step is to select the genes to be used for normalization. One method would be to first only use genes expressed in more than n cells, and then remove the most variable genes.

```{r, echo=FALSE, message=FALSE}
gene_subset_exp <- subset_genes(ex_sc, method = "Expression", threshold = 3, minCells = .05*(ncol(exprs(ex_sc)))) # filter genes on expression
gene_subset_var <- subset_genes(ex_sc, method = "PCA", threshold = 3, minCells = .05*(ncol(exprs(ex_sc))), nComp = 5, cutoff = 0.85) # filter genes on variability
stable_genes <- gene_subset_exp[!gene_subset_exp %in% gene_subset_var] # remove variable genes

clusters <- pData(ex_sc)[,"Cluster"]
getClusterSizes <- function (input)
{
  clu <- pData(input)$Cluster
  sizes <- c()
  for(i in 1:length(unique(pData(input)$Cluster))){
    sizes <- c(sizes, length(which(clu == paste0("Cluster", i))))
}
  return(sizes)
}
c_sizes <- getClusterSizes(ex_sc)
```

This is the maximum pool size. We generally aim for 5 sets of pool sizes (eg.20, 30, 40, 50, 60):

```{r, echo=FALSE, message=FALSE}
min(c_sizes) #
```

```{r, echo=FALSE, message=FALSE}
norm_sc_fixed <- function (input, genelist = gene_subset, pool_sizes = c(20, 30, 40, 50), positive = TRUE) 
{
  clusters <- pData(input)$Cluster
  larger.sce <- SingleCellExperiment(list(counts = exprs(input))) # fix
  larger.sce <- scran::computeSumFactors(larger.sce, cluster = clusters, subset.row = genelist, sizes = pool_sizes, positive = positive)
  larger.sce <- scater::normalise(larger.sce)
  norm_counts <- exprs(larger.sce)
  norm_counts[!is.finite(norm_counts)] <- 0
  norm_counts <- norm_counts[apply(norm_counts, 1, function(x) !all(x ==  0)), ]
  norm_counts <- norm_counts[, colSums(norm_counts) > 0]
  input_norm <- construct_ex_sc(norm_counts)
  ind <- match(colnames(input_norm), colnames(larger.sce))
  size_factor <- as.vector(unlist(larger.sce@int_colData)) # temprorary fix
  size_factor <- size_factor[ind]
  pData(input_norm)$size_factor <- size_factor
  return(input_norm)
}

ex_sc_norm <- norm_sc_fixed(ex_sc, genelist = stable_genes,  pool_sizes = c(20, 30, 40, 50))
```

# Post Normalization Pre-processing
Now that we have normalized, it is time to reprocess the data as before, this time on the normalized counts!

```{r, echo=FALSE, message=FALSE}
ex_sc_norm <- calc_libsize(ex_sc_norm)
plot_density(ex_sc_norm, title = "UMI Density", val = "UMI_sum", statistic = "mean") 
gene_subset <- subset_genes(ex_sc_norm, method = "PCA", threshold = 1, minCells = 30, nComp = 10, cutoff = 0.85)
ex_sc_norm <- dim_reduce(ex_sc_norm, genelist = gene_subset, pre_reduce = "iPCA", nComp = 15, tSNE_perp = 50, iterations = 500, print_progress=TRUE)
ex_sc_norm <- cluster_sc(ex_sc_norm, dimension = "2d", method = "density", s = 2)
c_sizes_norm <- getClusterSizes(ex_sc_norm)
plot_tsne_metadata(ex_sc_norm, color_by = "Cluster", title = "Spectral Cluster on iPCA components")
plot_density_ridge(ex_sc_norm, color_by = "Cluster", title = "UMIs per cluster", val = "UMI_sum")
plot_tsne_metadata(ex_sc_norm, color_by = "UMI_sum", title = "Total UMIs per cell") 
plot_tsne_metadata(ex_sc_norm, color_by = "size_factor", title = "Size Factor per cell") 
plot_tsne_metadata(ex_sc_norm, color_by = "iPC_Comp1", title = "PC1 cell loadings") 
plot_tsne_metadata(ex_sc_norm, color_by = "iPC_Comp2", title = "PC2 cell loadings") 
plot_tsne_metadata(ex_sc_norm, color_by = "iPC_Comp3", title = "PC3 cell loadings")
```

Cluster sizes before normalization:

```{r, echo=FALSE, message=FALSE}
c_sizes
```

Cluster sizes after normalization:

```{r, echo=FALSE, message=FALSE}
c_sizes_norm
```

Average UMI_sum/cell after normalization:

```{r, echo=FALSE, message=FALSE}
mean(pData(ex_sc_norm)$UMI_sum)
```

## Identifing markers and reference genes

```{r, echo=FALSE, message=FALSE}
ex_sc_norm <- id_markers(ex_sc_norm, print_progress = TRUE) # This is a quick method to find good markers genes for cell identification. These gene scores get written to fData(ex_sc_norm)
marker_list <- return_markers(ex_sc_norm, num_markers = 9) # However returning the genes as a list can be helpful
```

# Top 9 Marker for each cluster:

```{r, echo=FALSE, message=FALSE}
marker_list
                

for(i in 1:length(c_sizes_norm)){
    cluName = paste0("Cluster", i, "_Markers")
    print(plot_tsne_gene(input = ex_sc_norm, gene = marker_list[[cluName]][1:9], title = paste0("Top 9 markers for Cluster ",i),  ncol = 3, density = FALSE))
}
```